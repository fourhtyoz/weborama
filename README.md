# Описание задания 2:
## Описание ко второму тестовому заданию (парсер epub/fb2 на Python):

Скрипт запускается из командной строки в виде: _python3 task2.py \*название файла для парсинга\*_ (это обязательный аргумент (файл для обработки)). 

### Базовые случаи:
1. Нет аргумента - поднимается _TypeError_.
2. Если файл не может быть найден в папке со скриптом - _FileNotFoundError_.
3. Файл не в формате epub и  fb2 - создается исключение.

### EPUB

Если файл _epub_, то для его обработки используется модуль _ebooklib_. 
1. Создается функция c 3 аргументами: имя файла, формат метаданных (согласно документации, это обязательный аргумент, 
дефолтное значение _DC (Dublin Core)_ и список метаданных, значения которых требуется найти. 
Дефолтные значения соответствуют заданию: _название книги, имя автора, издательство, год издания_). 
2. Cоздаетcя экземпляр класса _ebooklib.epub.EpubBook_.
3. Создается пустой список res, который будет хранить полученные метаданные. 
4. Делается итерация через дефолтные значения в fields и используется метод _get_metadata_ для получения значения методанных.
5. Полученные значения сохраняются в список _res_.
6. Значение даты обрабатывается отдельно: год получается путем слайса [:4] строки с датой и временем из метаданных.
На выходе список в виде: __[“название книги”, “имя автора”, “издательство”, “год издания”]__.

### FB2

Если файл _fb2_, то для его обработки используется модуль _BeautifulSoup_, так как _fb2_ представляет собой _xml_ файл. 
1. Создается функция c 2 аргументами: имя файла и список метаданных, значения которых требуется найти (дефолтные значения соответствуют заданию: 
название книги, имя автора, издательство, год издания).
2. Открывается файл через контекстный менеджер _with open()_.
3. Содержимое преобразуется из листа в строку через _join_, чтобы подготовить данные для обработки в _BeautifulSoup_.
4. Создается объект для обработки в _BeautifulSoup_.
5. Создается пустой список _res_, который будет хранить полученные метаданные. 
6. Делается итерация через дефолтные значения в _fields_ и используется метод _find().text_ для получения значения метаданных.
7. Полученные значения сохраняются в список _res_.
8. Имя автора обрабатывается отдельно: находятся имя и фамилия, они заносятся в пустой список _name_ и преобразуются в строку через _' '.join_. 
Так как имя должно идти в конечном списке под индексом 1, то переменная _name_ вставляется в список _res_ через метод _insert_.
На выходе список в виде: __[“название книги”, “имя автора”, “издательство”, “год издания”]__.

Так как файл будет запускаться как скрипт, то прописывается _if \_\_name\_\_ == '\_\_main\_\_'_:,
в котором импортируется модуль _sys_ для чтения аргумента к скрипту (название файла для парсинга). 
В блоке также обрабатываются базовые случаи.


